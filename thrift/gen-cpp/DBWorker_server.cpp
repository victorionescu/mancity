// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include "DBWorker.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "mongo/client/dbclient.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mancity;
using namespace  ::bson;
using namespace  ::mongo;

class DBWorkerHandler : virtual public DBWorkerIf {
 public:
  DBWorkerHandler() {
    // Your initialization goes here
  }

  void ping() {
    // Your implementation goes here
    printf("ping\n");
  }

  void allTeams(TeamList& _return) {
    try {
      mongo::DBClientConnection c;
      c.connect("localhost");

      BSONObj constraints = BSON("_id" << 0 << "teamName" << 1 << "team_id" << 1);
      auto_ptr<DBClientCursor> cursor = c.query("mancity.teams", BSONObj(), 0, 0, &constraints);

      while (cursor->more()) {
        bo obj = cursor->next();

        Team* result = new Team();
        result->__set_teamName(obj.getField("teamName").String());
        result->__set_teamId((int)obj.getField("team_id").Double());

        _return.push_back(*result);
      }


    } catch(const mongo::DBException &e) {
      std::cout << "CAUGHT EXCEPTION IN DB INTERACTION\n";
    }
  }

  void teamPlayers(PlayerList& _return, const int32_t team_id) {
    try {
      mongo::DBClientConnection c;
      c.connect("localhost");

      BSONObj constraints = BSON("_id" << 0 << "players" << 1 << "teamName" << 1);
      auto_ptr<DBClientCursor> cursor = 
          c.query("mancity.teams",
                  QUERY("team_id" << team_id).sort("playerLastName"),
                  0,
                  0,
                  &constraints
          );

      while (cursor->more()) {
        bo team = cursor->next();

        if (team.hasElement("players")) {

          std::vector<BSONElement> players = team.getField("players").Array();

          for (unsigned int i = 0; i < players.size(); i++) {
            BSONObj player = players[i].embeddedObject();

            Player* player_to_add = new Player();
            player_to_add->__set_playerFirstName(player.getField("playerFirstName").String());
            player_to_add->__set_playerLastName(player.getField("playerLastName").String());

            _return.push_back(*player_to_add);
          }
        }
      }

    } catch(const mongo::DBException &e) {
      std::cout <<"CAUGHT EXCEPTION IN DB INTERACTION";
    }
    // Your implementation goes here
    printf("teamPlayers\n");
  }

  void playerAttributes(PlayerAttributes& _return, const int32_t team_id, const int32_t player_id) {
    // Your implementation goes here
    printf("playerAttributes\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<DBWorkerHandler> handler(new DBWorkerHandler());
  shared_ptr<TProcessor> processor(new DBWorkerProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

